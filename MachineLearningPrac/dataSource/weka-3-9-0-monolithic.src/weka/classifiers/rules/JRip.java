/*    1:     */ package weka.classifiers.rules;
/*    2:     */ 
/*    3:     */ import java.io.PrintStream;
/*    4:     */ import java.io.Serializable;
/*    5:     */ import java.util.ArrayList;
/*    6:     */ import java.util.Collections;
/*    7:     */ import java.util.Enumeration;
/*    8:     */ import java.util.Random;
/*    9:     */ import java.util.Vector;
/*   10:     */ import weka.classifiers.AbstractClassifier;
/*   11:     */ import weka.core.AdditionalMeasureProducer;
/*   12:     */ import weka.core.Attribute;
/*   13:     */ import weka.core.Capabilities;
/*   14:     */ import weka.core.Capabilities.Capability;
/*   15:     */ import weka.core.Copyable;
/*   16:     */ import weka.core.Instance;
/*   17:     */ import weka.core.Instances;
/*   18:     */ import weka.core.Option;
/*   19:     */ import weka.core.RevisionHandler;
/*   20:     */ import weka.core.RevisionUtils;
/*   21:     */ import weka.core.TechnicalInformation;
/*   22:     */ import weka.core.TechnicalInformation.Field;
/*   23:     */ import weka.core.TechnicalInformation.Type;
/*   24:     */ import weka.core.TechnicalInformationHandler;
/*   25:     */ import weka.core.Utils;
/*   26:     */ import weka.core.WeightedInstancesHandler;
/*   27:     */ import weka.filters.Filter;
/*   28:     */ import weka.filters.supervised.attribute.ClassOrder;
/*   29:     */ 
/*   30:     */ public class JRip
/*   31:     */   extends AbstractClassifier
/*   32:     */   implements AdditionalMeasureProducer, WeightedInstancesHandler, TechnicalInformationHandler
/*   33:     */ {
/*   34:     */   static final long serialVersionUID = -6589312996832147161L;
/*   35: 191 */   private static double MAX_DL_SURPLUS = 64.0D;
/*   36:     */   private Attribute m_Class;
/*   37:     */   private ArrayList<Rule> m_Ruleset;
/*   38:     */   private ArrayList<double[]> m_Distributions;
/*   39:     */   private int m_Optimizations;
/*   40:     */   private Random m_Random;
/*   41:     */   private double m_Total;
/*   42:     */   private long m_Seed;
/*   43:     */   private int m_Folds;
/*   44:     */   private double m_MinNo;
/*   45:     */   private boolean m_Debug;
/*   46:     */   private boolean m_CheckErr;
/*   47:     */   private boolean m_UsePruning;
/*   48:     */   private Filter m_Filter;
/*   49:     */   private ArrayList<RuleStats> m_RulesetStats;
/*   50:     */   
/*   51:     */   public JRip()
/*   52:     */   {
/*   53: 203 */     this.m_Optimizations = 2;
/*   54:     */     
/*   55:     */ 
/*   56: 206 */     this.m_Random = null;
/*   57:     */     
/*   58:     */ 
/*   59: 209 */     this.m_Total = 0.0D;
/*   60:     */     
/*   61:     */ 
/*   62: 212 */     this.m_Seed = 1L;
/*   63:     */     
/*   64:     */ 
/*   65: 215 */     this.m_Folds = 3;
/*   66:     */     
/*   67:     */ 
/*   68: 218 */     this.m_MinNo = 2.0D;
/*   69:     */     
/*   70:     */ 
/*   71: 221 */     this.m_Debug = false;
/*   72:     */     
/*   73:     */ 
/*   74: 224 */     this.m_CheckErr = true;
/*   75:     */     
/*   76:     */ 
/*   77: 227 */     this.m_UsePruning = true;
/*   78:     */     
/*   79:     */ 
/*   80: 230 */     this.m_Filter = null;
/*   81:     */   }
/*   82:     */   
/*   83:     */   public String globalInfo()
/*   84:     */   {
/*   85: 243 */     return "This class implements a propositional rule learner, Repeated Incremental Pruning to Produce Error Reduction (RIPPER), which was proposed by William W. Cohen as an optimized version of IREP. \n\nThe algorithm is briefly described as follows: \n\nInitialize RS = {}, and for each class from the less prevalent one to the more frequent one, DO: \n\n1. Building stage:\nRepeat 1.1 and 1.2 until the descrition length (DL) of the ruleset and examples is 64 bits greater than the smallest DL met so far, or there are no positive examples, or the error rate >= 50%. \n\n1.1. Grow phase:\nGrow one rule by greedily adding antecedents (or conditions) to the rule until the rule is perfect (i.e. 100% accurate).  The procedure tries every possible value of each attribute and selects the condition with highest information gain: p(log(p/t)-log(P/T)).\n\n1.2. Prune phase:\nIncrementally prune each rule and allow the pruning of any final sequences of the antecedents;The pruning metric is (p-n)/(p+n) -- but it's actually 2p/(p+n) -1, so in this implementation we simply use p/(p+n) (actually (p+1)/(p+n+2), thus if p+n is 0, it's 0.5).\n\n2. Optimization stage:\n after generating the initial ruleset {Ri}, generate and prune two variants of each rule Ri from randomized data using procedure 1.1 and 1.2. But one variant is generated from an empty rule while the other is generated by greedily adding antecedents to the original rule. Moreover, the pruning metric used here is (TP+TN)/(P+N).Then the smallest possible DL for each variant and the original rule is computed.  The variant with the minimal DL is selected as the final representative of Ri in the ruleset.After all the rules in {Ri} have been examined and if there are still residual positives, more rules are generated based on the residual positives using Building Stage again. \n3. Delete the rules from the ruleset that would increase the DL of the whole ruleset if it were in it. and add resultant ruleset to RS. \nENDDO\n\nNote that there seem to be 2 bugs in the original ripper program that would affect the ruleset size and accuracy slightly.  This implementation avoids these bugs and thus is a little bit different from Cohen's original implementation. Even after fixing the bugs, since the order of classes with the same frequency is not defined in ripper, there still seems to be some trivial difference between this implementation and the original ripper, especially for audiology data in UCI repository, where there are lots of classes of few instances.\n\nDetails please see:\n\n" + getTechnicalInformation().toString() + "\n\n" + "PS.  We have compared this implementation with the original ripper " + "implementation in aspects of accuracy, ruleset size and running time " + "on both artificial data \"ab+bcd+defg\" and UCI datasets.  In all these " + "aspects it seems to be quite comparable to the original ripper " + "implementation.  However, we didn't consider memory consumption " + "optimization in this implementation.\n\n";
/*   86:     */   }
/*   87:     */   
/*   88:     */   public TechnicalInformation getTechnicalInformation()
/*   89:     */   {
/*   90: 310 */     TechnicalInformation result = new TechnicalInformation(TechnicalInformation.Type.INPROCEEDINGS);
/*   91: 311 */     result.setValue(TechnicalInformation.Field.AUTHOR, "William W. Cohen");
/*   92: 312 */     result.setValue(TechnicalInformation.Field.TITLE, "Fast Effective Rule Induction");
/*   93: 313 */     result.setValue(TechnicalInformation.Field.BOOKTITLE, "Twelfth International Conference on Machine Learning");
/*   94:     */     
/*   95: 315 */     result.setValue(TechnicalInformation.Field.YEAR, "1995");
/*   96: 316 */     result.setValue(TechnicalInformation.Field.PAGES, "115-123");
/*   97: 317 */     result.setValue(TechnicalInformation.Field.PUBLISHER, "Morgan Kaufmann");
/*   98:     */     
/*   99: 319 */     return result;
/*  100:     */   }
/*  101:     */   
/*  102:     */   public Enumeration<Option> listOptions()
/*  103:     */   {
/*  104: 359 */     Vector<Option> newVector = new Vector(7);
/*  105: 360 */     newVector.add(new Option("\tSet number of folds for REP\n\tOne fold is used as pruning set.\n\t(default 3)", "F", 1, "-F <number of folds>"));
/*  106:     */     
/*  107:     */ 
/*  108: 363 */     newVector.add(new Option("\tSet the minimal weights of instances\n\twithin a split.\n\t(default 2.0)", "N", 1, "-N <min. weights>"));
/*  109:     */     
/*  110:     */ 
/*  111:     */ 
/*  112: 367 */     newVector.add(new Option("\tSet the number of runs of\n\toptimizations. (Default: 2)", "O", 1, "-O <number of runs>"));
/*  113:     */     
/*  114:     */ 
/*  115: 370 */     newVector.add(new Option("\tSet whether turn on the\n\tdebug mode (Default: false)", "D", 0, "-D"));
/*  116:     */     
/*  117:     */ 
/*  118: 373 */     newVector.add(new Option("\tThe seed of randomization\n\t(Default: 1)", "S", 1, "-S <seed>"));
/*  119:     */     
/*  120:     */ 
/*  121: 376 */     newVector.add(new Option("\tWhether NOT check the error rate>=0.5\n\tin stopping criteria \t(default: check)", "E", 0, "-E"));
/*  122:     */     
/*  123:     */ 
/*  124: 379 */     newVector.add(new Option("\tWhether NOT use pruning\n\t(default: use pruning)", "P", 0, "-P"));
/*  125:     */     
/*  126:     */ 
/*  127: 382 */     newVector.addAll(Collections.list(super.listOptions()));
/*  128:     */     
/*  129: 384 */     return newVector.elements();
/*  130:     */   }
/*  131:     */   
/*  132:     */   public void setOptions(String[] options)
/*  133:     */     throws Exception
/*  134:     */   {
/*  135: 445 */     String numFoldsString = Utils.getOption('F', options);
/*  136: 446 */     if (numFoldsString.length() != 0) {
/*  137: 447 */       this.m_Folds = Integer.parseInt(numFoldsString);
/*  138:     */     } else {
/*  139: 449 */       this.m_Folds = 3;
/*  140:     */     }
/*  141: 452 */     String minNoString = Utils.getOption('N', options);
/*  142: 453 */     if (minNoString.length() != 0) {
/*  143: 454 */       this.m_MinNo = Double.parseDouble(minNoString);
/*  144:     */     } else {
/*  145: 456 */       this.m_MinNo = 2.0D;
/*  146:     */     }
/*  147: 459 */     String seedString = Utils.getOption('S', options);
/*  148: 460 */     if (seedString.length() != 0) {
/*  149: 461 */       this.m_Seed = Long.parseLong(seedString);
/*  150:     */     } else {
/*  151: 463 */       this.m_Seed = 1L;
/*  152:     */     }
/*  153: 466 */     String runString = Utils.getOption('O', options);
/*  154: 467 */     if (runString.length() != 0) {
/*  155: 468 */       this.m_Optimizations = Integer.parseInt(runString);
/*  156:     */     } else {
/*  157: 470 */       this.m_Optimizations = 2;
/*  158:     */     }
/*  159: 473 */     this.m_Debug = Utils.getFlag('D', options);
/*  160: 474 */     this.m_CheckErr = (!Utils.getFlag('E', options));
/*  161: 475 */     this.m_UsePruning = (!Utils.getFlag('P', options));
/*  162:     */     
/*  163: 477 */     super.setOptions(options);
/*  164:     */     
/*  165: 479 */     Utils.checkForRemainingOptions(options);
/*  166:     */   }
/*  167:     */   
/*  168:     */   public String[] getOptions()
/*  169:     */   {
/*  170: 490 */     Vector<String> options = new Vector();
/*  171:     */     
/*  172: 492 */     options.add("-F");
/*  173: 493 */     options.add("" + this.m_Folds);
/*  174: 494 */     options.add("-N");
/*  175: 495 */     options.add("" + this.m_MinNo);
/*  176: 496 */     options.add("-O");
/*  177: 497 */     options.add("" + this.m_Optimizations);
/*  178: 498 */     options.add("-S");
/*  179: 499 */     options.add("" + this.m_Seed);
/*  180: 501 */     if (this.m_Debug) {
/*  181: 502 */       options.add("-D");
/*  182:     */     }
/*  183: 505 */     if (!this.m_CheckErr) {
/*  184: 506 */       options.add("-E");
/*  185:     */     }
/*  186: 509 */     if (!this.m_UsePruning) {
/*  187: 510 */       options.add("-P");
/*  188:     */     }
/*  189: 513 */     Collections.addAll(options, super.getOptions());
/*  190:     */     
/*  191: 515 */     return (String[])options.toArray(new String[0]);
/*  192:     */   }
/*  193:     */   
/*  194:     */   public Enumeration<String> enumerateMeasures()
/*  195:     */   {
/*  196: 525 */     Vector<String> newVector = new Vector(1);
/*  197: 526 */     newVector.add("measureNumRules");
/*  198: 527 */     return newVector.elements();
/*  199:     */   }
/*  200:     */   
/*  201:     */   public double getMeasure(String additionalMeasureName)
/*  202:     */   {
/*  203: 539 */     if (additionalMeasureName.compareToIgnoreCase("measureNumRules") == 0) {
/*  204: 540 */       return this.m_Ruleset.size();
/*  205:     */     }
/*  206: 542 */     throw new IllegalArgumentException(additionalMeasureName + " not supported (RIPPER)");
/*  207:     */   }
/*  208:     */   
/*  209:     */   public String foldsTipText()
/*  210:     */   {
/*  211: 554 */     return "Determines the amount of data used for pruning. One fold is used for pruning, the rest for growing the rules.";
/*  212:     */   }
/*  213:     */   
/*  214:     */   public void setFolds(int fold)
/*  215:     */   {
/*  216: 564 */     this.m_Folds = fold;
/*  217:     */   }
/*  218:     */   
/*  219:     */   public int getFolds()
/*  220:     */   {
/*  221: 573 */     return this.m_Folds;
/*  222:     */   }
/*  223:     */   
/*  224:     */   public String minNoTipText()
/*  225:     */   {
/*  226: 583 */     return "The minimum total weight of the instances in a rule.";
/*  227:     */   }
/*  228:     */   
/*  229:     */   public void setMinNo(double m)
/*  230:     */   {
/*  231: 592 */     this.m_MinNo = m;
/*  232:     */   }
/*  233:     */   
/*  234:     */   public double getMinNo()
/*  235:     */   {
/*  236: 601 */     return this.m_MinNo;
/*  237:     */   }
/*  238:     */   
/*  239:     */   public String seedTipText()
/*  240:     */   {
/*  241: 611 */     return "The seed used for randomizing the data.";
/*  242:     */   }
/*  243:     */   
/*  244:     */   public void setSeed(long s)
/*  245:     */   {
/*  246: 620 */     this.m_Seed = s;
/*  247:     */   }
/*  248:     */   
/*  249:     */   public long getSeed()
/*  250:     */   {
/*  251: 629 */     return this.m_Seed;
/*  252:     */   }
/*  253:     */   
/*  254:     */   public String optimizationsTipText()
/*  255:     */   {
/*  256: 639 */     return "The number of optimization runs.";
/*  257:     */   }
/*  258:     */   
/*  259:     */   public void setOptimizations(int run)
/*  260:     */   {
/*  261: 648 */     this.m_Optimizations = run;
/*  262:     */   }
/*  263:     */   
/*  264:     */   public int getOptimizations()
/*  265:     */   {
/*  266: 657 */     return this.m_Optimizations;
/*  267:     */   }
/*  268:     */   
/*  269:     */   public String debugTipText()
/*  270:     */   {
/*  271: 668 */     return "Whether debug information is output to the console.";
/*  272:     */   }
/*  273:     */   
/*  274:     */   public void setDebug(boolean d)
/*  275:     */   {
/*  276: 678 */     this.m_Debug = d;
/*  277:     */   }
/*  278:     */   
/*  279:     */   public boolean getDebug()
/*  280:     */   {
/*  281: 688 */     return this.m_Debug;
/*  282:     */   }
/*  283:     */   
/*  284:     */   public String checkErrorRateTipText()
/*  285:     */   {
/*  286: 698 */     return "Whether check for error rate >= 1/2 is included in stopping criterion.";
/*  287:     */   }
/*  288:     */   
/*  289:     */   public void setCheckErrorRate(boolean d)
/*  290:     */   {
/*  291: 708 */     this.m_CheckErr = d;
/*  292:     */   }
/*  293:     */   
/*  294:     */   public boolean getCheckErrorRate()
/*  295:     */   {
/*  296: 717 */     return this.m_CheckErr;
/*  297:     */   }
/*  298:     */   
/*  299:     */   public String usePruningTipText()
/*  300:     */   {
/*  301: 727 */     return "Whether pruning is performed.";
/*  302:     */   }
/*  303:     */   
/*  304:     */   public void setUsePruning(boolean d)
/*  305:     */   {
/*  306: 736 */     this.m_UsePruning = d;
/*  307:     */   }
/*  308:     */   
/*  309:     */   public boolean getUsePruning()
/*  310:     */   {
/*  311: 745 */     return this.m_UsePruning;
/*  312:     */   }
/*  313:     */   
/*  314:     */   public ArrayList<Rule> getRuleset()
/*  315:     */   {
/*  316: 754 */     return this.m_Ruleset;
/*  317:     */   }
/*  318:     */   
/*  319:     */   public RuleStats getRuleStats(int pos)
/*  320:     */   {
/*  321: 764 */     return (RuleStats)this.m_RulesetStats.get(pos);
/*  322:     */   }
/*  323:     */   
/*  324:     */   public abstract class Antd
/*  325:     */     implements WeightedInstancesHandler, Copyable, Serializable, RevisionHandler
/*  326:     */   {
/*  327:     */     private static final long serialVersionUID = -8929754772994154334L;
/*  328:     */     protected Attribute att;
/*  329:     */     protected double value;
/*  330:     */     protected double maxInfoGain;
/*  331:     */     protected double accuRate;
/*  332:     */     protected double cover;
/*  333:     */     protected double accu;
/*  334:     */     
/*  335:     */     public Antd(Attribute a)
/*  336:     */     {
/*  337: 806 */       this.att = a;
/*  338: 807 */       this.value = (0.0D / 0.0D);
/*  339: 808 */       this.maxInfoGain = 0.0D;
/*  340: 809 */       this.accuRate = (0.0D / 0.0D);
/*  341: 810 */       this.cover = (0.0D / 0.0D);
/*  342: 811 */       this.accu = (0.0D / 0.0D);
/*  343:     */     }
/*  344:     */     
/*  345:     */     public abstract Instances[] splitData(Instances paramInstances, double paramDouble1, double paramDouble2);
/*  346:     */     
/*  347:     */     public abstract boolean covers(Instance paramInstance);
/*  348:     */     
/*  349:     */     public abstract String toString();
/*  350:     */     
/*  351:     */     public abstract Object copy();
/*  352:     */     
/*  353:     */     public Attribute getAttr()
/*  354:     */     {
/*  355: 833 */       return this.att;
/*  356:     */     }
/*  357:     */     
/*  358:     */     public double getAttrValue()
/*  359:     */     {
/*  360: 837 */       return this.value;
/*  361:     */     }
/*  362:     */     
/*  363:     */     public double getMaxInfoGain()
/*  364:     */     {
/*  365: 841 */       return this.maxInfoGain;
/*  366:     */     }
/*  367:     */     
/*  368:     */     public double getAccuRate()
/*  369:     */     {
/*  370: 845 */       return this.accuRate;
/*  371:     */     }
/*  372:     */     
/*  373:     */     public double getAccu()
/*  374:     */     {
/*  375: 849 */       return this.accu;
/*  376:     */     }
/*  377:     */     
/*  378:     */     public double getCover()
/*  379:     */     {
/*  380: 853 */       return this.cover;
/*  381:     */     }
/*  382:     */     
/*  383:     */     public String getRevision()
/*  384:     */     {
/*  385: 863 */       return RevisionUtils.extract("$Revision: 10153 $");
/*  386:     */     }
/*  387:     */   }
/*  388:     */   
/*  389:     */   public class NumericAntd
/*  390:     */     extends JRip.Antd
/*  391:     */   {
/*  392:     */     static final long serialVersionUID = 5699457269983735442L;
/*  393:     */     private double splitPoint;
/*  394:     */     
/*  395:     */     public NumericAntd(Attribute a)
/*  396:     */     {
/*  397: 882 */       super(a);
/*  398: 883 */       this.splitPoint = (0.0D / 0.0D);
/*  399:     */     }
/*  400:     */     
/*  401:     */     public double getSplitPoint()
/*  402:     */     {
/*  403: 892 */       return this.splitPoint;
/*  404:     */     }
/*  405:     */     
/*  406:     */     public Object copy()
/*  407:     */     {
/*  408: 902 */       NumericAntd na = new NumericAntd(JRip.this, getAttr());
/*  409: 903 */       na.value = this.value;
/*  410: 904 */       na.splitPoint = this.splitPoint;
/*  411: 905 */       return na;
/*  412:     */     }
/*  413:     */     
/*  414:     */     public Instances[] splitData(Instances insts, double defAcRt, double cl)
/*  415:     */     {
/*  416: 920 */       Instances data = insts;
/*  417: 921 */       int total = data.numInstances();
/*  418:     */       
/*  419:     */ 
/*  420: 924 */       int split = 1;
/*  421: 925 */       int prev = 0;
/*  422: 926 */       int finalSplit = split;
/*  423: 927 */       this.maxInfoGain = 0.0D;
/*  424: 928 */       this.value = 0.0D;
/*  425:     */       
/*  426: 930 */       double fstCover = 0.0D;double sndCover = 0.0D;double fstAccu = 0.0D;double sndAccu = 0.0D;
/*  427:     */       
/*  428: 932 */       data.sort(this.att);
/*  429: 934 */       for (int x = 0; x < data.numInstances(); x++)
/*  430:     */       {
/*  431: 935 */         Instance inst = data.instance(x);
/*  432: 936 */         if (inst.isMissing(this.att))
/*  433:     */         {
/*  434: 937 */           total = x;
/*  435: 938 */           break;
/*  436:     */         }
/*  437: 941 */         sndCover += inst.weight();
/*  438: 942 */         if (Utils.eq(inst.classValue(), cl)) {
/*  439: 943 */           sndAccu += inst.weight();
/*  440:     */         }
/*  441:     */       }
/*  442: 947 */       if (total == 0) {
/*  443: 948 */         return null;
/*  444:     */       }
/*  445: 950 */       this.splitPoint = data.instance(total - 1).value(this.att);
/*  446: 952 */       for (; split <= total; split++) {
/*  447: 953 */         if ((split == total) || (data.instance(split).value(this.att) > data.instance(prev).value(this.att)))
/*  448:     */         {
/*  449: 958 */           for (int y = prev; y < split; y++)
/*  450:     */           {
/*  451: 959 */             Instance inst = data.instance(y);
/*  452: 960 */             fstCover += inst.weight();
/*  453: 961 */             if (Utils.eq(data.instance(y).classValue(), cl)) {
/*  454: 962 */               fstAccu += inst.weight();
/*  455:     */             }
/*  456:     */           }
/*  457: 966 */           double fstAccuRate = (fstAccu + 1.0D) / (fstCover + 1.0D);double sndAccuRate = (sndAccu + 1.0D) / (sndCover + 1.0D);
/*  458:     */           
/*  459:     */ 
/*  460:     */ 
/*  461:     */ 
/*  462:     */ 
/*  463:     */ 
/*  464:     */ 
/*  465: 974 */           double fstInfoGain = fstAccu * (Utils.log2(fstAccuRate) - Utils.log2(defAcRt));
/*  466:     */           
/*  467:     */ 
/*  468:     */ 
/*  469:     */ 
/*  470: 979 */           double sndInfoGain = sndAccu * (Utils.log2(sndAccuRate) - Utils.log2(defAcRt));
/*  471:     */           double coverage;
/*  472:     */           boolean isFirst;
/*  473:     */           double infoGain;
/*  474:     */           double accRate;
/*  475:     */           double accurate;
/*  476:     */           double coverage;
/*  477: 984 */           if (fstInfoGain > sndInfoGain)
/*  478:     */           {
/*  479: 985 */             boolean isFirst = true;
/*  480: 986 */             double infoGain = fstInfoGain;
/*  481: 987 */             double accRate = fstAccuRate;
/*  482: 988 */             double accurate = fstAccu;
/*  483: 989 */             coverage = fstCover;
/*  484:     */           }
/*  485:     */           else
/*  486:     */           {
/*  487: 991 */             isFirst = false;
/*  488: 992 */             infoGain = sndInfoGain;
/*  489: 993 */             accRate = sndAccuRate;
/*  490: 994 */             accurate = sndAccu;
/*  491: 995 */             coverage = sndCover;
/*  492:     */           }
/*  493: 999 */           if (infoGain > this.maxInfoGain)
/*  494:     */           {
/*  495:1000 */             this.splitPoint = data.instance(prev).value(this.att);
/*  496:1001 */             this.value = (isFirst ? 0.0D : 1.0D);
/*  497:1002 */             this.accuRate = accRate;
/*  498:1003 */             this.accu = accurate;
/*  499:1004 */             this.cover = coverage;
/*  500:1005 */             this.maxInfoGain = infoGain;
/*  501:1006 */             finalSplit = isFirst ? split : prev;
/*  502:     */           }
/*  503:1009 */           for (int y = prev; y < split; y++)
/*  504:     */           {
/*  505:1010 */             Instance inst = data.instance(y);
/*  506:1011 */             sndCover -= inst.weight();
/*  507:1012 */             if (Utils.eq(data.instance(y).classValue(), cl)) {
/*  508:1013 */               sndAccu -= inst.weight();
/*  509:     */             }
/*  510:     */           }
/*  511:1016 */           prev = split;
/*  512:     */         }
/*  513:     */       }
/*  514:1021 */       Instances[] splitData = new Instances[2];
/*  515:1022 */       splitData[0] = new Instances(data, 0, finalSplit);
/*  516:1023 */       splitData[1] = new Instances(data, finalSplit, total - finalSplit);
/*  517:     */       
/*  518:1025 */       return splitData;
/*  519:     */     }
/*  520:     */     
/*  521:     */     public boolean covers(Instance inst)
/*  522:     */     {
/*  523:1037 */       boolean isCover = true;
/*  524:1038 */       if (!inst.isMissing(this.att))
/*  525:     */       {
/*  526:1039 */         if ((int)this.value == 0)
/*  527:     */         {
/*  528:1040 */           if (inst.value(this.att) > this.splitPoint) {
/*  529:1041 */             isCover = false;
/*  530:     */           }
/*  531:     */         }
/*  532:1043 */         else if (inst.value(this.att) < this.splitPoint) {
/*  533:1044 */           isCover = false;
/*  534:     */         }
/*  535:     */       }
/*  536:     */       else {
/*  537:1047 */         isCover = false;
/*  538:     */       }
/*  539:1050 */       return isCover;
/*  540:     */     }
/*  541:     */     
/*  542:     */     public String toString()
/*  543:     */     {
/*  544:1060 */       String symbol = (int)this.value == 0 ? " <= " : " >= ";
/*  545:1061 */       return this.att.name() + symbol + Utils.doubleToString(this.splitPoint, 6);
/*  546:     */     }
/*  547:     */     
/*  548:     */     public String getRevision()
/*  549:     */     {
/*  550:1071 */       return RevisionUtils.extract("$Revision: 10153 $");
/*  551:     */     }
/*  552:     */   }
/*  553:     */   
/*  554:     */   public class NominalAntd
/*  555:     */     extends JRip.Antd
/*  556:     */   {
/*  557:     */     static final long serialVersionUID = -9102297038837585135L;
/*  558:     */     private final double[] accurate;
/*  559:     */     private final double[] coverage;
/*  560:     */     
/*  561:     */     public NominalAntd(Attribute a)
/*  562:     */     {
/*  563:1094 */       super(a);
/*  564:1095 */       int bag = this.att.numValues();
/*  565:1096 */       this.accurate = new double[bag];
/*  566:1097 */       this.coverage = new double[bag];
/*  567:     */     }
/*  568:     */     
/*  569:     */     public Object copy()
/*  570:     */     {
/*  571:1107 */       JRip.Antd antec = new NominalAntd(JRip.this, getAttr());
/*  572:1108 */       antec.value = this.value;
/*  573:1109 */       return antec;
/*  574:     */     }
/*  575:     */     
/*  576:     */     public Instances[] splitData(Instances data, double defAcRt, double cl)
/*  577:     */     {
/*  578:1124 */       int bag = this.att.numValues();
/*  579:1125 */       Instances[] splitData = new Instances[bag];
/*  580:1127 */       for (int x = 0; x < bag; x++)
/*  581:     */       {
/*  582:1128 */         splitData[x] = new Instances(data, data.numInstances());
/*  583:1129 */         this.accurate[x] = 0.0D;
/*  584:1130 */         this.coverage[x] = 0.0D;
/*  585:     */       }
/*  586:1133 */       for (int x = 0; x < data.numInstances(); x++)
/*  587:     */       {
/*  588:1134 */         Instance inst = data.instance(x);
/*  589:1135 */         if (!inst.isMissing(this.att))
/*  590:     */         {
/*  591:1136 */           int v = (int)inst.value(this.att);
/*  592:1137 */           splitData[v].add(inst);
/*  593:1138 */           this.coverage[v] += inst.weight();
/*  594:1139 */           if ((int)inst.classValue() == (int)cl) {
/*  595:1140 */             this.accurate[v] += inst.weight();
/*  596:     */           }
/*  597:     */         }
/*  598:     */       }
/*  599:1145 */       for (int x = 0; x < bag; x++)
/*  600:     */       {
/*  601:1146 */         double t = this.coverage[x] + 1.0D;
/*  602:1147 */         double p = this.accurate[x] + 1.0D;
/*  603:1148 */         double infoGain = this.accurate[x] * (Utils.log2(p / t) - Utils.log2(defAcRt));
/*  604:1153 */         if (infoGain > this.maxInfoGain)
/*  605:     */         {
/*  606:1154 */           this.maxInfoGain = infoGain;
/*  607:1155 */           this.cover = this.coverage[x];
/*  608:1156 */           this.accu = this.accurate[x];
/*  609:1157 */           this.accuRate = (p / t);
/*  610:1158 */           this.value = x;
/*  611:     */         }
/*  612:     */       }
/*  613:1162 */       return splitData;
/*  614:     */     }
/*  615:     */     
/*  616:     */     public boolean covers(Instance inst)
/*  617:     */     {
/*  618:1174 */       boolean isCover = false;
/*  619:1175 */       if ((!inst.isMissing(this.att)) && 
/*  620:1176 */         ((int)inst.value(this.att) == (int)this.value)) {
/*  621:1177 */         isCover = true;
/*  622:     */       }
/*  623:1180 */       return isCover;
/*  624:     */     }
/*  625:     */     
/*  626:     */     public String toString()
/*  627:     */     {
/*  628:1190 */       return this.att.name() + " = " + this.att.value((int)this.value);
/*  629:     */     }
/*  630:     */     
/*  631:     */     public String getRevision()
/*  632:     */     {
/*  633:1200 */       return RevisionUtils.extract("$Revision: 10153 $");
/*  634:     */     }
/*  635:     */   }
/*  636:     */   
/*  637:     */   public class RipperRule
/*  638:     */     extends Rule
/*  639:     */   {
/*  640:     */     static final long serialVersionUID = -2410020717305262952L;
/*  641:1219 */     private double m_Consequent = -1.0D;
/*  642:1222 */     protected ArrayList<JRip.Antd> m_Antds = null;
/*  643:     */     
/*  644:     */     public RipperRule()
/*  645:     */     {
/*  646:1226 */       this.m_Antds = new ArrayList();
/*  647:     */     }
/*  648:     */     
/*  649:     */     public void setConsequent(double cl)
/*  650:     */     {
/*  651:1235 */       this.m_Consequent = cl;
/*  652:     */     }
/*  653:     */     
/*  654:     */     public double getConsequent()
/*  655:     */     {
/*  656:1245 */       return this.m_Consequent;
/*  657:     */     }
/*  658:     */     
/*  659:     */     public Object copy()
/*  660:     */     {
/*  661:1255 */       RipperRule copy = new RipperRule(JRip.this);
/*  662:1256 */       copy.setConsequent(getConsequent());
/*  663:1257 */       copy.m_Antds = new ArrayList(this.m_Antds.size());
/*  664:1258 */       for (JRip.Antd a : this.m_Antds) {
/*  665:1259 */         copy.m_Antds.add((JRip.Antd)a.copy());
/*  666:     */       }
/*  667:1261 */       return copy;
/*  668:     */     }
/*  669:     */     
/*  670:     */     public boolean covers(Instance datum)
/*  671:     */     {
/*  672:1273 */       boolean isCover = true;
/*  673:1275 */       for (int i = 0; i < this.m_Antds.size(); i++)
/*  674:     */       {
/*  675:1276 */         JRip.Antd antd = (JRip.Antd)this.m_Antds.get(i);
/*  676:1277 */         if (!antd.covers(datum))
/*  677:     */         {
/*  678:1278 */           isCover = false;
/*  679:1279 */           break;
/*  680:     */         }
/*  681:     */       }
/*  682:1283 */       return isCover;
/*  683:     */     }
/*  684:     */     
/*  685:     */     public boolean hasAntds()
/*  686:     */     {
/*  687:1293 */       if (this.m_Antds == null) {
/*  688:1294 */         return false;
/*  689:     */       }
/*  690:1296 */       return this.m_Antds.size() > 0;
/*  691:     */     }
/*  692:     */     
/*  693:     */     public ArrayList<JRip.Antd> getAntds()
/*  694:     */     {
/*  695:1306 */       return this.m_Antds;
/*  696:     */     }
/*  697:     */     
/*  698:     */     public double size()
/*  699:     */     {
/*  700:1316 */       return this.m_Antds.size();
/*  701:     */     }
/*  702:     */     
/*  703:     */     private double computeDefAccu(Instances data)
/*  704:     */     {
/*  705:1327 */       double defAccu = 0.0D;
/*  706:1328 */       for (int i = 0; i < data.numInstances(); i++)
/*  707:     */       {
/*  708:1329 */         Instance inst = data.instance(i);
/*  709:1330 */         if ((int)inst.classValue() == (int)this.m_Consequent) {
/*  710:1331 */           defAccu += inst.weight();
/*  711:     */         }
/*  712:     */       }
/*  713:1334 */       return defAccu;
/*  714:     */     }
/*  715:     */     
/*  716:     */     public void grow(Instances data)
/*  717:     */       throws Exception
/*  718:     */     {
/*  719:1345 */       if (this.m_Consequent == -1.0D) {
/*  720:1346 */         throw new Exception(" Consequent not set yet.");
/*  721:     */       }
/*  722:1349 */       Instances growData = data;
/*  723:1350 */       double sumOfWeights = growData.sumOfWeights();
/*  724:1351 */       if (!Utils.gr(sumOfWeights, 0.0D)) {
/*  725:1352 */         return;
/*  726:     */       }
/*  727:1356 */       double defAccu = computeDefAccu(growData);
/*  728:1357 */       double defAcRt = (defAccu + 1.0D) / (sumOfWeights + 1.0D);
/*  729:     */       
/*  730:     */ 
/*  731:1360 */       boolean[] used = new boolean[growData.numAttributes()];
/*  732:1361 */       for (int k = 0; k < used.length; k++) {
/*  733:1362 */         used[k] = false;
/*  734:     */       }
/*  735:1364 */       int numUnused = used.length;
/*  736:1367 */       for (int j = 0; j < this.m_Antds.size(); j++)
/*  737:     */       {
/*  738:1368 */         JRip.Antd antdj = (JRip.Antd)this.m_Antds.get(j);
/*  739:1369 */         if (!antdj.getAttr().isNumeric())
/*  740:     */         {
/*  741:1370 */           used[antdj.getAttr().index()] = true;
/*  742:1371 */           numUnused--;
/*  743:     */         }
/*  744:     */       }
/*  745:1377 */       while ((Utils.gr(growData.numInstances(), 0.0D)) && (numUnused > 0) && (Utils.sm(defAcRt, 1.0D)))
/*  746:     */       {
/*  747:1385 */         double maxInfoGain = 0.0D;
/*  748:     */         
/*  749:     */ 
/*  750:1388 */         JRip.Antd oneAntd = null;
/*  751:1389 */         Instances coverData = null;
/*  752:1390 */         Enumeration<Attribute> enumAttr = growData.enumerateAttributes();
/*  753:1393 */         while (enumAttr.hasMoreElements())
/*  754:     */         {
/*  755:1394 */           Attribute att = (Attribute)enumAttr.nextElement();
/*  756:1396 */           if (JRip.this.m_Debug) {
/*  757:1397 */             System.err.println("\nOne condition: size = " + growData.sumOfWeights());
/*  758:     */           }
/*  759:1401 */           JRip.Antd antd = null;
/*  760:1402 */           if (att.isNumeric()) {
/*  761:1403 */             antd = new JRip.NumericAntd(JRip.this, att);
/*  762:     */           } else {
/*  763:1405 */             antd = new JRip.NominalAntd(JRip.this, att);
/*  764:     */           }
/*  765:1408 */           if (used[att.index()] == 0)
/*  766:     */           {
/*  767:1414 */             Instances coveredData = computeInfoGain(growData, defAcRt, antd);
/*  768:1415 */             if (coveredData != null)
/*  769:     */             {
/*  770:1416 */               double infoGain = antd.getMaxInfoGain();
/*  771:1417 */               if (JRip.this.m_Debug) {
/*  772:1418 */                 System.err.println("Test of '" + antd.toString() + "': infoGain = " + infoGain + " | Accuracy = " + antd.getAccuRate() + "=" + antd.getAccu() + "/" + antd.getCover() + " def. accuracy: " + defAcRt);
/*  773:     */               }
/*  774:1424 */               if (infoGain > maxInfoGain)
/*  775:     */               {
/*  776:1425 */                 oneAntd = antd;
/*  777:1426 */                 coverData = coveredData;
/*  778:1427 */                 maxInfoGain = infoGain;
/*  779:     */               }
/*  780:     */             }
/*  781:     */           }
/*  782:     */         }
/*  783:1433 */         if (oneAntd == null) {
/*  784:     */           break;
/*  785:     */         }
/*  786:1436 */         if (Utils.sm(oneAntd.getAccu(), JRip.this.m_MinNo)) {
/*  787:     */           break;
/*  788:     */         }
/*  789:1441 */         if (!oneAntd.getAttr().isNumeric())
/*  790:     */         {
/*  791:1442 */           used[oneAntd.getAttr().index()] = true;
/*  792:1443 */           numUnused--;
/*  793:     */         }
/*  794:1446 */         this.m_Antds.add(oneAntd);
/*  795:1447 */         growData = coverData;
/*  796:1448 */         defAcRt = oneAntd.getAccuRate();
/*  797:     */       }
/*  798:     */     }
/*  799:     */     
/*  800:     */     private Instances computeInfoGain(Instances instances, double defAcRt, JRip.Antd antd)
/*  801:     */     {
/*  802:1463 */       Instances data = instances;
/*  803:     */       
/*  804:     */ 
/*  805:     */ 
/*  806:     */ 
/*  807:     */ 
/*  808:1469 */       Instances[] splitData = antd.splitData(data, defAcRt, this.m_Consequent);
/*  809:1472 */       if (splitData != null) {
/*  810:1473 */         return splitData[((int)antd.getAttrValue())];
/*  811:     */       }
/*  812:1475 */       return null;
/*  813:     */     }
/*  814:     */     
/*  815:     */     public void prune(Instances pruneData, boolean useWhole)
/*  816:     */     {
/*  817:1488 */       Instances data = pruneData;
/*  818:     */       
/*  819:1490 */       double total = data.sumOfWeights();
/*  820:1491 */       if (!Utils.gr(total, 0.0D)) {
/*  821:1492 */         return;
/*  822:     */       }
/*  823:1496 */       double defAccu = computeDefAccu(data);
/*  824:1498 */       if (JRip.this.m_Debug) {
/*  825:1499 */         System.err.println("Pruning with " + defAccu + " positive data out of " + total + " instances");
/*  826:     */       }
/*  827:1503 */       int size = this.m_Antds.size();
/*  828:1504 */       if (size == 0) {
/*  829:1505 */         return;
/*  830:     */       }
/*  831:1508 */       double[] worthRt = new double[size];
/*  832:1509 */       double[] coverage = new double[size];
/*  833:1510 */       double[] worthValue = new double[size];
/*  834:1511 */       for (int w = 0; w < size; w++)
/*  835:     */       {
/*  836:1512 */         double tmp134_133 = (worthValue[w] = 0.0D);coverage[w] = tmp134_133;worthRt[w] = tmp134_133;
/*  837:     */       }
/*  838:1516 */       double tn = 0.0D;
/*  839:1517 */       for (int x = 0; x < size; x++)
/*  840:     */       {
/*  841:1518 */         JRip.Antd antd = (JRip.Antd)this.m_Antds.get(x);
/*  842:1519 */         Instances newData = data;
/*  843:1520 */         data = new Instances(newData, 0);
/*  844:1522 */         for (int y = 0; y < newData.numInstances(); y++)
/*  845:     */         {
/*  846:1523 */           Instance ins = newData.instance(y);
/*  847:1525 */           if (antd.covers(ins))
/*  848:     */           {
/*  849:1526 */             coverage[x] += ins.weight();
/*  850:1527 */             data.add(ins);
/*  851:1528 */             if ((int)ins.classValue() == (int)this.m_Consequent) {
/*  852:1529 */               worthValue[x] += ins.weight();
/*  853:     */             }
/*  854:     */           }
/*  855:1531 */           else if ((useWhole) && 
/*  856:1532 */             ((int)ins.classValue() != (int)this.m_Consequent))
/*  857:     */           {
/*  858:1533 */             tn += ins.weight();
/*  859:     */           }
/*  860:     */         }
/*  861:1538 */         if (useWhole)
/*  862:     */         {
/*  863:1539 */           worthValue[x] += tn;
/*  864:1540 */           worthValue[x] /= total;
/*  865:     */         }
/*  866:     */         else
/*  867:     */         {
/*  868:1542 */           worthRt[x] = ((worthValue[x] + 1.0D) / (coverage[x] + 2.0D));
/*  869:     */         }
/*  870:     */       }
/*  871:1546 */       double maxValue = (defAccu + 1.0D) / (total + 2.0D);
/*  872:1547 */       int maxIndex = -1;
/*  873:1548 */       for (int i = 0; i < worthValue.length; i++)
/*  874:     */       {
/*  875:1549 */         if (JRip.this.m_Debug)
/*  876:     */         {
/*  877:1550 */           double denom = useWhole ? total : coverage[i];
/*  878:1551 */           System.err.println(i + "(useAccuray? " + (!useWhole) + "): " + worthRt[i] + "=" + worthValue[i] + "/" + denom);
/*  879:     */         }
/*  880:1554 */         if (worthRt[i] > maxValue)
/*  881:     */         {
/*  882:1555 */           maxValue = worthRt[i];
/*  883:1556 */           maxIndex = i;
/*  884:     */         }
/*  885:     */       }
/*  886:1561 */       for (int z = size - 1; z > maxIndex; z--) {
/*  887:1562 */         this.m_Antds.remove(z);
/*  888:     */       }
/*  889:     */     }
/*  890:     */     
/*  891:     */     public String toString(Attribute classAttr)
/*  892:     */     {
/*  893:1573 */       StringBuffer text = new StringBuffer();
/*  894:1574 */       if (this.m_Antds.size() > 0)
/*  895:     */       {
/*  896:1575 */         for (int j = 0; j < this.m_Antds.size() - 1; j++) {
/*  897:1576 */           text.append("(" + ((JRip.Antd)this.m_Antds.get(j)).toString() + ") and ");
/*  898:     */         }
/*  899:1578 */         text.append("(" + ((JRip.Antd)this.m_Antds.get(this.m_Antds.size() - 1)).toString() + ")");
/*  900:     */       }
/*  901:1580 */       text.append(" => " + classAttr.name() + "=" + classAttr.value((int)this.m_Consequent));
/*  902:     */       
/*  903:     */ 
/*  904:1583 */       return text.toString();
/*  905:     */     }
/*  906:     */     
/*  907:     */     public String getRevision()
/*  908:     */     {
/*  909:1593 */       return RevisionUtils.extract("$Revision: 10153 $");
/*  910:     */     }
/*  911:     */   }
/*  912:     */   
/*  913:     */   public Capabilities getCapabilities()
/*  914:     */   {
/*  915:1604 */     Capabilities result = super.getCapabilities();
/*  916:1605 */     result.disableAll();
/*  917:     */     
/*  918:     */ 
/*  919:1608 */     result.enable(Capabilities.Capability.NOMINAL_ATTRIBUTES);
/*  920:1609 */     result.enable(Capabilities.Capability.NUMERIC_ATTRIBUTES);
/*  921:1610 */     result.enable(Capabilities.Capability.DATE_ATTRIBUTES);
/*  922:1611 */     result.enable(Capabilities.Capability.MISSING_VALUES);
/*  923:     */     
/*  924:     */ 
/*  925:1614 */     result.enable(Capabilities.Capability.NOMINAL_CLASS);
/*  926:1615 */     result.enable(Capabilities.Capability.MISSING_CLASS_VALUES);
/*  927:     */     
/*  928:     */ 
/*  929:1618 */     result.setMinimumNumberInstances(this.m_Folds);
/*  930:     */     
/*  931:1620 */     return result;
/*  932:     */   }
/*  933:     */   
/*  934:     */   public void buildClassifier(Instances instances)
/*  935:     */     throws Exception
/*  936:     */   {
/*  937:1634 */     getCapabilities().testWithFail(instances);
/*  938:     */     
/*  939:     */ 
/*  940:1637 */     instances = new Instances(instances);
/*  941:1638 */     instances.deleteWithMissingClass();
/*  942:     */     
/*  943:1640 */     this.m_Random = instances.getRandomNumberGenerator(this.m_Seed);
/*  944:1641 */     this.m_Total = RuleStats.numAllConditions(instances);
/*  945:1642 */     if (this.m_Debug) {
/*  946:1643 */       System.err.println("Number of all possible conditions = " + this.m_Total);
/*  947:     */     }
/*  948:1646 */     Instances data = null;
/*  949:1647 */     this.m_Filter = new ClassOrder();
/*  950:1648 */     ((ClassOrder)this.m_Filter).setSeed(this.m_Random.nextInt());
/*  951:1649 */     ((ClassOrder)this.m_Filter).setClassOrder(0);
/*  952:1650 */     this.m_Filter.setInputFormat(instances);
/*  953:1651 */     data = Filter.useFilter(instances, this.m_Filter);
/*  954:1653 */     if (data == null) {
/*  955:1654 */       throw new Exception(" Unable to randomize the class orders.");
/*  956:     */     }
/*  957:1657 */     this.m_Class = data.classAttribute();
/*  958:1658 */     this.m_Ruleset = new ArrayList();
/*  959:1659 */     this.m_RulesetStats = new ArrayList();
/*  960:1660 */     this.m_Distributions = new ArrayList();
/*  961:     */     
/*  962:     */ 
/*  963:1663 */     double[] orderedClasses = ((ClassOrder)this.m_Filter).getClassCounts();
/*  964:1664 */     if (this.m_Debug)
/*  965:     */     {
/*  966:1665 */       System.err.println("Sorted classes:");
/*  967:1666 */       for (int x = 0; x < this.m_Class.numValues(); x++) {
/*  968:1667 */         System.err.println(x + ": " + this.m_Class.value(x) + " has " + orderedClasses[x] + " instances.");
/*  969:     */       }
/*  970:     */     }
/*  971:1672 */     for (int y = 0; y < data.numClasses() - 1; y++)
/*  972:     */     {
/*  973:1675 */       double classIndex = y;
/*  974:1676 */       if (this.m_Debug)
/*  975:     */       {
/*  976:1677 */         int ci = (int)classIndex;
/*  977:1678 */         System.err.println("\n\nClass " + this.m_Class.value(ci) + "(" + ci + "): " + orderedClasses[y] + "instances\n" + "=====================================\n");
/*  978:     */       }
/*  979:1683 */       if (!Utils.eq(orderedClasses[y], 0.0D))
/*  980:     */       {
/*  981:1688 */         double all = 0.0D;
/*  982:1689 */         for (int i = y; i < orderedClasses.length; i++) {
/*  983:1690 */           all += orderedClasses[i];
/*  984:     */         }
/*  985:1692 */         double expFPRate = orderedClasses[y] / all;
/*  986:     */         
/*  987:1694 */         double classYWeights = 0.0D;double totalWeights = 0.0D;
/*  988:1695 */         for (int j = 0; j < data.numInstances(); j++)
/*  989:     */         {
/*  990:1696 */           Instance datum = data.instance(j);
/*  991:1697 */           totalWeights += datum.weight();
/*  992:1698 */           if ((int)datum.classValue() == y) {
/*  993:1699 */             classYWeights += datum.weight();
/*  994:     */           }
/*  995:     */         }
/*  996:1705 */         if (classYWeights > 0.0D)
/*  997:     */         {
/*  998:1706 */           double defDL = RuleStats.dataDL(expFPRate, 0.0D, totalWeights, 0.0D, classYWeights);
/*  999:1712 */           if ((Double.isNaN(defDL)) || (Double.isInfinite(defDL))) {
/* 1000:1713 */             throw new Exception("Should never happen: defDL NaN or infinite!");
/* 1001:     */           }
/* 1002:1715 */           if (this.m_Debug) {
/* 1003:1716 */             System.err.println("The default DL = " + defDL);
/* 1004:     */           }
/* 1005:1719 */           data = rulesetForOneClass(expFPRate, data, classIndex, defDL);
/* 1006:     */         }
/* 1007:     */       }
/* 1008:     */     }
/* 1009:1723 */     RipperRule defRule = new RipperRule();
/* 1010:1724 */     defRule.setConsequent(data.numClasses() - 1);
/* 1011:1725 */     this.m_Ruleset.add(defRule);
/* 1012:     */     
/* 1013:1727 */     RuleStats defRuleStat = new RuleStats();
/* 1014:1728 */     defRuleStat.setData(data);
/* 1015:1729 */     defRuleStat.setNumAllConds(this.m_Total);
/* 1016:1730 */     defRuleStat.addAndUpdate(defRule);
/* 1017:1731 */     this.m_RulesetStats.add(defRuleStat);
/* 1018:1733 */     for (int z = 0; z < this.m_RulesetStats.size(); z++)
/* 1019:     */     {
/* 1020:1734 */       RuleStats oneClass = (RuleStats)this.m_RulesetStats.get(z);
/* 1021:1735 */       for (int xyz = 0; xyz < oneClass.getRulesetSize(); xyz++)
/* 1022:     */       {
/* 1023:1736 */         double[] classDist = oneClass.getDistributions(xyz);
/* 1024:1737 */         Utils.normalize(classDist);
/* 1025:1738 */         if (classDist != null) {
/* 1026:1739 */           this.m_Distributions.add(((ClassOrder)this.m_Filter).distributionsByOriginalIndex(classDist));
/* 1027:     */         }
/* 1028:     */       }
/* 1029:     */     }
/* 1030:1746 */     for (int i = 0; i < this.m_RulesetStats.size(); i++) {
/* 1031:1747 */       ((RuleStats)this.m_RulesetStats.get(i)).cleanUp();
/* 1032:     */     }
/* 1033:     */   }
/* 1034:     */   
/* 1035:     */   public double[] distributionForInstance(Instance datum)
/* 1036:     */   {
/* 1037:     */     try
/* 1038:     */     {
/* 1039:1761 */       for (int i = 0; i < this.m_Ruleset.size(); i++)
/* 1040:     */       {
/* 1041:1762 */         Rule rule = (Rule)this.m_Ruleset.get(i);
/* 1042:1763 */         if (rule.covers(datum)) {
/* 1043:1764 */           return (double[])this.m_Distributions.get(i);
/* 1044:     */         }
/* 1045:     */       }
/* 1046:     */     }
/* 1047:     */     catch (Exception e)
/* 1048:     */     {
/* 1049:1768 */       System.err.println(e.getMessage());
/* 1050:1769 */       e.printStackTrace();
/* 1051:     */     }
/* 1052:1772 */     System.err.println("Should never happen!");
/* 1053:1773 */     return new double[datum.classAttribute().numValues()];
/* 1054:     */   }
/* 1055:     */   
/* 1056:     */   protected Instances rulesetForOneClass(double expFPRate, Instances data, double classIndex, double defDL)
/* 1057:     */     throws Exception
/* 1058:     */   {
/* 1059:1788 */     Instances newData = data;
/* 1060:1789 */     boolean stop = false;
/* 1061:1790 */     ArrayList<Rule> ruleset = new ArrayList();
/* 1062:     */     
/* 1063:1792 */     double dl = defDL;double minDL = defDL;
/* 1064:1793 */     RuleStats rstats = null;
/* 1065:     */     
/* 1066:     */ 
/* 1067:     */ 
/* 1068:1797 */     boolean defHasPositive = true;
/* 1069:1798 */     boolean hasPositive = defHasPositive;
/* 1070:1801 */     if (this.m_Debug) {
/* 1071:1802 */       System.err.println("\n*** Building stage ***");
/* 1072:     */     }
/* 1073:1805 */     while ((!stop) && (hasPositive))
/* 1074:     */     {
/* 1075:     */       RipperRule oneRule;
/* 1076:1808 */       if (this.m_UsePruning)
/* 1077:     */       {
/* 1078:1815 */         newData = RuleStats.stratify(newData, this.m_Folds, this.m_Random);
/* 1079:1816 */         Instances[] part = RuleStats.partition(newData, this.m_Folds);
/* 1080:1817 */         Instances growData = part[0];
/* 1081:1818 */         Instances pruneData = part[1];
/* 1082:     */         
/* 1083:     */ 
/* 1084:     */ 
/* 1085:1822 */         RipperRule oneRule = new RipperRule();
/* 1086:1823 */         oneRule.setConsequent(classIndex);
/* 1087:1825 */         if (this.m_Debug) {
/* 1088:1826 */           System.err.println("\nGrowing a rule ...");
/* 1089:     */         }
/* 1090:1828 */         oneRule.grow(growData);
/* 1091:1829 */         if (this.m_Debug) {
/* 1092:1830 */           System.err.println("One rule found before pruning:" + oneRule.toString(this.m_Class));
/* 1093:     */         }
/* 1094:1834 */         if (this.m_Debug) {
/* 1095:1835 */           System.err.println("\nPruning the rule ...");
/* 1096:     */         }
/* 1097:1837 */         oneRule.prune(pruneData, false);
/* 1098:1838 */         if (this.m_Debug) {
/* 1099:1839 */           System.err.println("One rule found after pruning:" + oneRule.toString(this.m_Class));
/* 1100:     */         }
/* 1101:     */       }
/* 1102:     */       else
/* 1103:     */       {
/* 1104:1843 */         oneRule = new RipperRule();
/* 1105:1844 */         oneRule.setConsequent(classIndex);
/* 1106:1845 */         if (this.m_Debug) {
/* 1107:1846 */           System.err.println("\nNo pruning: growing a rule ...");
/* 1108:     */         }
/* 1109:1848 */         oneRule.grow(newData);
/* 1110:1849 */         if (this.m_Debug) {
/* 1111:1850 */           System.err.println("No pruning: one rule found:\n" + oneRule.toString(this.m_Class));
/* 1112:     */         }
/* 1113:     */       }
/* 1114:1856 */       if (rstats == null)
/* 1115:     */       {
/* 1116:1857 */         rstats = new RuleStats();
/* 1117:1858 */         rstats.setNumAllConds(this.m_Total);
/* 1118:1859 */         rstats.setData(newData);
/* 1119:     */       }
/* 1120:1862 */       rstats.addAndUpdate(oneRule);
/* 1121:1863 */       int last = rstats.getRuleset().size() - 1;
/* 1122:1864 */       dl += rstats.relativeDL(last, expFPRate, this.m_CheckErr);
/* 1123:1866 */       if ((Double.isNaN(dl)) || (Double.isInfinite(dl))) {
/* 1124:1867 */         throw new Exception("Should never happen: dl in building stage NaN or infinite!");
/* 1125:     */       }
/* 1126:1870 */       if (this.m_Debug) {
/* 1127:1871 */         System.err.println("Before optimization(" + last + "): the dl = " + dl + " | best: " + minDL);
/* 1128:     */       }
/* 1129:1875 */       if (dl < minDL) {
/* 1130:1876 */         minDL = dl;
/* 1131:     */       }
/* 1132:1879 */       double[] rst = rstats.getSimpleStats(last);
/* 1133:1880 */       if (this.m_Debug) {
/* 1134:1881 */         System.err.println("The rule covers: " + rst[0] + " | pos = " + rst[2] + " | neg = " + rst[4] + "\nThe rule doesn't cover: " + rst[1] + " | pos = " + rst[5]);
/* 1135:     */       }
/* 1136:1886 */       stop = checkStop(rst, minDL, dl);
/* 1137:1888 */       if (!stop)
/* 1138:     */       {
/* 1139:1889 */         ruleset.add(oneRule);
/* 1140:1890 */         newData = rstats.getFiltered(last)[1];
/* 1141:1891 */         hasPositive = Utils.gr(rst[5], 0.0D);
/* 1142:1892 */         if (this.m_Debug) {
/* 1143:1893 */           System.err.println("One rule added: has positive? " + hasPositive);
/* 1144:     */         }
/* 1145:     */       }
/* 1146:     */       else
/* 1147:     */       {
/* 1148:1896 */         if (this.m_Debug) {
/* 1149:1897 */           System.err.println("Quit rule");
/* 1150:     */         }
/* 1151:1899 */         rstats.removeLast();
/* 1152:     */       }
/* 1153:     */     }
/* 1154:1904 */     RuleStats finalRulesetStat = null;
/* 1155:1905 */     if (this.m_UsePruning) {
/* 1156:1906 */       for (int z = 0; z < this.m_Optimizations; z++)
/* 1157:     */       {
/* 1158:1907 */         if (this.m_Debug) {
/* 1159:1908 */           System.err.println("\n*** Optimization: run #" + z + " ***");
/* 1160:     */         }
/* 1161:1911 */         newData = data;
/* 1162:1912 */         finalRulesetStat = new RuleStats();
/* 1163:1913 */         finalRulesetStat.setData(newData);
/* 1164:1914 */         finalRulesetStat.setNumAllConds(this.m_Total);
/* 1165:1915 */         int position = 0;
/* 1166:1916 */         stop = false;
/* 1167:1917 */         boolean isResidual = false;
/* 1168:1918 */         hasPositive = defHasPositive;
/* 1169:1919 */         dl = minDL = defDL;
/* 1170:1921 */         while ((!stop) && (hasPositive))
/* 1171:     */         {
/* 1172:1923 */           isResidual = position >= ruleset.size();
/* 1173:     */           
/* 1174:     */ 
/* 1175:     */ 
/* 1176:1927 */           newData = RuleStats.stratify(newData, this.m_Folds, this.m_Random);
/* 1177:1928 */           Instances[] part = RuleStats.partition(newData, this.m_Folds);
/* 1178:1929 */           Instances growData = part[0];
/* 1179:1930 */           Instances pruneData = part[1];
/* 1180:1935 */           if (this.m_Debug) {
/* 1181:1936 */             System.err.println("\nRule #" + position + "| isResidual?" + isResidual + "| data size: " + newData.sumOfWeights());
/* 1182:     */           }
/* 1183:     */           RipperRule finalRule;
/* 1184:1940 */           if (isResidual)
/* 1185:     */           {
/* 1186:1941 */             RipperRule newRule = new RipperRule();
/* 1187:1942 */             newRule.setConsequent(classIndex);
/* 1188:1943 */             if (this.m_Debug) {
/* 1189:1944 */               System.err.println("\nGrowing and pruning a new rule ...");
/* 1190:     */             }
/* 1191:1946 */             newRule.grow(growData);
/* 1192:1947 */             newRule.prune(pruneData, false);
/* 1193:1948 */             RipperRule finalRule = newRule;
/* 1194:1949 */             if (this.m_Debug) {
/* 1195:1950 */               System.err.println("\nNew rule found: " + newRule.toString(this.m_Class));
/* 1196:     */             }
/* 1197:     */           }
/* 1198:     */           else
/* 1199:     */           {
/* 1200:1954 */             RipperRule oldRule = (RipperRule)ruleset.get(position);
/* 1201:1955 */             boolean covers = false;
/* 1202:1957 */             for (int i = 0; i < newData.numInstances(); i++) {
/* 1203:1958 */               if (oldRule.covers(newData.instance(i)))
/* 1204:     */               {
/* 1205:1959 */                 covers = true;
/* 1206:1960 */                 break;
/* 1207:     */               }
/* 1208:     */             }
/* 1209:1964 */             if (!covers)
/* 1210:     */             {
/* 1211:1965 */               finalRulesetStat.addAndUpdate(oldRule);
/* 1212:1966 */               position++;
/* 1213:1967 */               continue;
/* 1214:     */             }
/* 1215:1971 */             if (this.m_Debug) {
/* 1216:1972 */               System.err.println("\nGrowing and pruning Replace ...");
/* 1217:     */             }
/* 1218:1974 */             RipperRule replace = new RipperRule();
/* 1219:1975 */             replace.setConsequent(classIndex);
/* 1220:1976 */             replace.grow(growData);
/* 1221:     */             
/* 1222:     */ 
/* 1223:     */ 
/* 1224:     */ 
/* 1225:     */ 
/* 1226:     */ 
/* 1227:1983 */             pruneData = RuleStats.rmCoveredBySuccessives(pruneData, ruleset, position);
/* 1228:     */             
/* 1229:1985 */             replace.prune(pruneData, true);
/* 1230:1987 */             if (this.m_Debug) {
/* 1231:1988 */               System.err.println("\nGrowing and pruning Revision ...");
/* 1232:     */             }
/* 1233:1990 */             RipperRule revision = (RipperRule)oldRule.copy();
/* 1234:     */             
/* 1235:     */ 
/* 1236:1993 */             Instances newGrowData = new Instances(growData, 0);
/* 1237:1994 */             for (int b = 0; b < growData.numInstances(); b++)
/* 1238:     */             {
/* 1239:1995 */               Instance inst = growData.instance(b);
/* 1240:1996 */               if (revision.covers(inst)) {
/* 1241:1997 */                 newGrowData.add(inst);
/* 1242:     */               }
/* 1243:     */             }
/* 1244:2000 */             revision.grow(newGrowData);
/* 1245:2001 */             revision.prune(pruneData, true);
/* 1246:     */             
/* 1247:2003 */             double[][] prevRuleStats = new double[position][6];
/* 1248:2004 */             for (int c = 0; c < position; c++) {
/* 1249:2005 */               prevRuleStats[c] = finalRulesetStat.getSimpleStats(c);
/* 1250:     */             }
/* 1251:2009 */             ArrayList<Rule> tempRules = new ArrayList(ruleset.size());
/* 1252:2010 */             for (Rule r : ruleset) {
/* 1253:2011 */               tempRules.add((Rule)r.copy());
/* 1254:     */             }
/* 1255:2013 */             tempRules.set(position, replace);
/* 1256:     */             
/* 1257:2015 */             RuleStats repStat = new RuleStats(data, tempRules);
/* 1258:2016 */             repStat.setNumAllConds(this.m_Total);
/* 1259:2017 */             repStat.countData(position, newData, prevRuleStats);
/* 1260:     */             
/* 1261:2019 */             double[] rst = repStat.getSimpleStats(position);
/* 1262:2020 */             if (this.m_Debug) {
/* 1263:2021 */               System.err.println("Replace rule covers: " + rst[0] + " | pos = " + rst[2] + " | neg = " + rst[4] + "\nThe rule doesn't cover: " + rst[1] + " | pos = " + rst[5]);
/* 1264:     */             }
/* 1265:2026 */             double repDL = repStat.relativeDL(position, expFPRate, this.m_CheckErr);
/* 1266:2027 */             if (this.m_Debug) {
/* 1267:2028 */               System.err.println("\nReplace: " + replace.toString(this.m_Class) + " |dl = " + repDL);
/* 1268:     */             }
/* 1269:2032 */             if ((Double.isNaN(repDL)) || (Double.isInfinite(repDL))) {
/* 1270:2033 */               throw new Exception("Should never happen: repDLin optmz. stage NaN or infinite!");
/* 1271:     */             }
/* 1272:2037 */             tempRules.set(position, revision);
/* 1273:2038 */             RuleStats revStat = new RuleStats(data, tempRules);
/* 1274:2039 */             revStat.setNumAllConds(this.m_Total);
/* 1275:2040 */             revStat.countData(position, newData, prevRuleStats);
/* 1276:     */             
/* 1277:2042 */             double revDL = revStat.relativeDL(position, expFPRate, this.m_CheckErr);
/* 1278:2044 */             if (this.m_Debug) {
/* 1279:2045 */               System.err.println("Revision: " + revision.toString(this.m_Class) + " |dl = " + revDL);
/* 1280:     */             }
/* 1281:2049 */             if ((Double.isNaN(revDL)) || (Double.isInfinite(revDL))) {
/* 1282:2050 */               throw new Exception("Should never happen: revDLin optmz. stage NaN or infinite!");
/* 1283:     */             }
/* 1284:2054 */             rstats = new RuleStats(data, ruleset);
/* 1285:2055 */             rstats.setNumAllConds(this.m_Total);
/* 1286:2056 */             rstats.countData(position, newData, prevRuleStats);
/* 1287:     */             
/* 1288:2058 */             double oldDL = rstats.relativeDL(position, expFPRate, this.m_CheckErr);
/* 1289:2060 */             if ((Double.isNaN(oldDL)) || (Double.isInfinite(oldDL))) {
/* 1290:2061 */               throw new Exception("Should never happen: oldDLin optmz. stage NaN or infinite!");
/* 1291:     */             }
/* 1292:2064 */             if (this.m_Debug) {
/* 1293:2065 */               System.err.println("Old rule: " + oldRule.toString(this.m_Class) + " |dl = " + oldDL);
/* 1294:     */             }
/* 1295:2069 */             if (this.m_Debug) {
/* 1296:2070 */               System.err.println("\nrepDL: " + repDL + "\nrevDL: " + revDL + "\noldDL: " + oldDL);
/* 1297:     */             }
/* 1298:     */             RipperRule finalRule;
/* 1299:2074 */             if ((oldDL <= revDL) && (oldDL <= repDL))
/* 1300:     */             {
/* 1301:2075 */               finalRule = oldRule;
/* 1302:     */             }
/* 1303:     */             else
/* 1304:     */             {
/* 1305:     */               RipperRule finalRule;
/* 1306:2076 */               if (revDL <= repDL) {
/* 1307:2077 */                 finalRule = revision;
/* 1308:     */               } else {
/* 1309:2079 */                 finalRule = replace;
/* 1310:     */               }
/* 1311:     */             }
/* 1312:     */           }
/* 1313:2083 */           finalRulesetStat.addAndUpdate(finalRule);
/* 1314:2084 */           double[] rst = finalRulesetStat.getSimpleStats(position);
/* 1315:2086 */           if (isResidual)
/* 1316:     */           {
/* 1317:2088 */             dl += finalRulesetStat.relativeDL(position, expFPRate, this.m_CheckErr);
/* 1318:2089 */             if (this.m_Debug) {
/* 1319:2090 */               System.err.println("After optimization: the dl=" + dl + " | best: " + minDL);
/* 1320:     */             }
/* 1321:2094 */             if (dl < minDL) {
/* 1322:2095 */               minDL = dl;
/* 1323:     */             }
/* 1324:2098 */             stop = checkStop(rst, minDL, dl);
/* 1325:2099 */             if (!stop)
/* 1326:     */             {
/* 1327:2100 */               ruleset.add(finalRule);
/* 1328:     */             }
/* 1329:     */             else
/* 1330:     */             {
/* 1331:2102 */               finalRulesetStat.removeLast();
/* 1332:2103 */               position--;
/* 1333:     */             }
/* 1334:     */           }
/* 1335:     */           else
/* 1336:     */           {
/* 1337:2106 */             ruleset.set(position, finalRule);
/* 1338:     */           }
/* 1339:2109 */           if (this.m_Debug)
/* 1340:     */           {
/* 1341:2110 */             System.err.println("The rule covers: " + rst[0] + " | pos = " + rst[2] + " | neg = " + rst[4] + "\nThe rule doesn't cover: " + rst[1] + " | pos = " + rst[5]);
/* 1342:     */             
/* 1343:     */ 
/* 1344:2113 */             System.err.println("\nRuleset so far: ");
/* 1345:2114 */             for (int x = 0; x < ruleset.size(); x++) {
/* 1346:2115 */               System.err.println(x + ": " + ((RipperRule)ruleset.get(x)).toString(this.m_Class));
/* 1347:     */             }
/* 1348:2118 */             System.err.println();
/* 1349:     */           }
/* 1350:2122 */           if (finalRulesetStat.getRulesetSize() > 0) {
/* 1351:2123 */             newData = finalRulesetStat.getFiltered(position)[1];
/* 1352:     */           }
/* 1353:2125 */           hasPositive = Utils.gr(rst[5], 0.0D);
/* 1354:2126 */           position++;
/* 1355:     */         }
/* 1356:2129 */         if (ruleset.size() > position + 1) {
/* 1357:2130 */           for (int k = position + 1; k < ruleset.size(); k++) {
/* 1358:2131 */             finalRulesetStat.addAndUpdate((Rule)ruleset.get(k));
/* 1359:     */           }
/* 1360:     */         }
/* 1361:2134 */         if (this.m_Debug) {
/* 1362:2135 */           System.err.println("\nDeleting rules to decrease DL of the whole ruleset ...");
/* 1363:     */         }
/* 1364:2138 */         finalRulesetStat.reduceDL(expFPRate, this.m_CheckErr);
/* 1365:2139 */         if (this.m_Debug)
/* 1366:     */         {
/* 1367:2140 */           int del = ruleset.size() - finalRulesetStat.getRulesetSize();
/* 1368:2141 */           System.err.println(del + " rules are deleted" + " after DL reduction procedure");
/* 1369:     */         }
/* 1370:2144 */         ruleset = finalRulesetStat.getRuleset();
/* 1371:2145 */         rstats = finalRulesetStat;
/* 1372:     */       }
/* 1373:     */     }
/* 1374:2151 */     if (this.m_Debug)
/* 1375:     */     {
/* 1376:2152 */       System.err.println("\nFinal ruleset: ");
/* 1377:2153 */       for (int x = 0; x < ruleset.size(); x++) {
/* 1378:2154 */         System.err.println(x + ": " + ((RipperRule)ruleset.get(x)).toString(this.m_Class));
/* 1379:     */       }
/* 1380:2157 */       System.err.println();
/* 1381:     */     }
/* 1382:2160 */     this.m_Ruleset.addAll(ruleset);
/* 1383:2161 */     this.m_RulesetStats.add(rstats);
/* 1384:2163 */     if (ruleset.size() > 0) {
/* 1385:2164 */       return rstats.getFiltered(ruleset.size() - 1)[1];
/* 1386:     */     }
/* 1387:2166 */     return data;
/* 1388:     */   }
/* 1389:     */   
/* 1390:     */   private boolean checkStop(double[] rst, double minDL, double dl)
/* 1391:     */   {
/* 1392:2180 */     if (dl > minDL + MAX_DL_SURPLUS)
/* 1393:     */     {
/* 1394:2181 */       if (this.m_Debug) {
/* 1395:2182 */         System.err.println("DL too large: " + dl + " | " + minDL);
/* 1396:     */       }
/* 1397:2184 */       return true;
/* 1398:     */     }
/* 1399:2185 */     if (!Utils.gr(rst[2], 0.0D))
/* 1400:     */     {
/* 1401:2186 */       if (this.m_Debug) {
/* 1402:2187 */         System.err.println("Too few positives.");
/* 1403:     */       }
/* 1404:2189 */       return true;
/* 1405:     */     }
/* 1406:2190 */     if (rst[4] / rst[0] >= 0.5D)
/* 1407:     */     {
/* 1408:2191 */       if (this.m_CheckErr)
/* 1409:     */       {
/* 1410:2192 */         if (this.m_Debug) {
/* 1411:2193 */           System.err.println("Error too large: " + rst[4] + "/" + rst[0]);
/* 1412:     */         }
/* 1413:2195 */         return true;
/* 1414:     */       }
/* 1415:2197 */       return false;
/* 1416:     */     }
/* 1417:2200 */     if (this.m_Debug) {
/* 1418:2201 */       System.err.println("Continue.");
/* 1419:     */     }
/* 1420:2203 */     return false;
/* 1421:     */   }
/* 1422:     */   
/* 1423:     */   public String toString()
/* 1424:     */   {
/* 1425:2214 */     if (this.m_Ruleset == null) {
/* 1426:2215 */       return "JRIP: No model built yet.";
/* 1427:     */     }
/* 1428:2218 */     StringBuffer sb = new StringBuffer("JRIP rules:\n===========\n\n");
/* 1429:2219 */     for (int j = 0; j < this.m_RulesetStats.size(); j++)
/* 1430:     */     {
/* 1431:2220 */       RuleStats rs = (RuleStats)this.m_RulesetStats.get(j);
/* 1432:2221 */       ArrayList<Rule> rules = rs.getRuleset();
/* 1433:2222 */       for (int k = 0; k < rules.size(); k++)
/* 1434:     */       {
/* 1435:2223 */         double[] simStats = rs.getSimpleStats(k);
/* 1436:2224 */         sb.append(((RipperRule)rules.get(k)).toString(this.m_Class) + " (" + simStats[0] + "/" + simStats[4] + ")\n");
/* 1437:     */       }
/* 1438:     */     }
/* 1439:2228 */     if (this.m_Debug)
/* 1440:     */     {
/* 1441:2229 */       System.err.println("Inside m_Ruleset");
/* 1442:2230 */       for (int i = 0; i < this.m_Ruleset.size(); i++) {
/* 1443:2231 */         System.err.println(((RipperRule)this.m_Ruleset.get(i)).toString(this.m_Class));
/* 1444:     */       }
/* 1445:     */     }
/* 1446:2234 */     sb.append("\nNumber of Rules : " + this.m_Ruleset.size() + "\n");
/* 1447:2235 */     return sb.toString();
/* 1448:     */   }
/* 1449:     */   
/* 1450:     */   public String getRevision()
/* 1451:     */   {
/* 1452:2245 */     return RevisionUtils.extract("$Revision: 10153 $");
/* 1453:     */   }
/* 1454:     */   
/* 1455:     */   public static void main(String[] args)
/* 1456:     */   {
/* 1457:2254 */     runClassifier(new JRip(), args);
/* 1458:     */   }
/* 1459:     */ }


/* Location:           C:\Users\Administrator\Desktop\weka-3-9-0-monolithic.jar
 * Qualified Name:     weka.classifiers.rules.JRip
 * JD-Core Version:    0.7.0.1
 */